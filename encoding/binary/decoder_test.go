package binary

import (
	"fmt"
	"net"
	"slices"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"go.voiplens.io/hep"
)

var sipPayload = []byte{
	0x53, 0x49, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x20, 0x32, 0x30, 0x30, 0x20, 0x4f, 0x4b, 0x0d, 0x0a,
	0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x42, 0x43, 0x30, 0x39, 0x39, 0x38, 0x38,
	0x34, 0x40, 0x36, 0x64, 0x66, 0x63, 0x66, 0x66, 0x65, 0x38, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71,
	0x3a, 0x20, 0x32, 0x31, 0x35, 0x38, 0x33, 0x34, 0x34, 0x38, 0x39, 0x20, 0x4f, 0x50, 0x54, 0x49,
	0x4f, 0x4e, 0x53, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a,
	0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x31, 0x31, 0x2e, 0x31, 0x31, 0x31, 0x3a,
	0x35, 0x30, 0x36, 0x30, 0x3e, 0x3b, 0x74, 0x61, 0x67, 0x3d, 0x36, 0x64, 0x66, 0x63, 0x66, 0x66,
	0x65, 0x38, 0x2b, 0x31, 0x2b, 0x62, 0x30, 0x61, 0x39, 0x30, 0x30, 0x30, 0x33, 0x2b, 0x63, 0x39,
	0x65, 0x66, 0x63, 0x32, 0x30, 0x62, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x73, 0x69, 0x70,
	0x3a, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x31, 0x31, 0x2e, 0x31, 0x31, 0x31,
	0x3a, 0x35, 0x30, 0x36, 0x30, 0x3b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x3d,
	0x75, 0x64, 0x70, 0x3e, 0x3b, 0x74, 0x61, 0x67, 0x3d, 0x31, 0x38, 0x30, 0x34, 0x61, 0x34, 0x37,
	0x64, 0x2b, 0x31, 0x2b, 0x65, 0x31, 0x30, 0x35, 0x30, 0x34, 0x37, 0x30, 0x2b, 0x62, 0x31, 0x32,
	0x38, 0x61, 0x35, 0x36, 0x39, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x53, 0x49, 0x50, 0x2f,
	0x32, 0x2e, 0x30, 0x2f, 0x55, 0x44, 0x50, 0x20, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e,
	0x31, 0x31, 0x31, 0x2e, 0x31, 0x31, 0x31, 0x3a, 0x35, 0x30, 0x36, 0x30, 0x3b, 0x62, 0x72, 0x61,
	0x6e, 0x63, 0x68, 0x3d, 0x7a, 0x39, 0x68, 0x47, 0x34, 0x62, 0x4b, 0x2b, 0x32, 0x31, 0x66, 0x31,
	0x31, 0x33, 0x65, 0x37, 0x65, 0x33, 0x64, 0x30, 0x34, 0x63, 0x38, 0x34, 0x36, 0x31, 0x34, 0x38,
	0x61, 0x39, 0x61, 0x64, 0x37, 0x36, 0x30, 0x37, 0x61, 0x65, 0x66, 0x61, 0x31, 0x2b, 0x36, 0x64,
	0x66, 0x63, 0x66, 0x66, 0x65, 0x38, 0x2b, 0x31, 0x0d, 0x0a, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x3a, 0x20, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
	0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x37, 0x38, 0x0d, 0x0a, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c,
	0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x73, 0x64, 0x70, 0x0d, 0x0a, 0x53, 0x75, 0x70,
	0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x3a, 0x20, 0x31, 0x30, 0x30, 0x72, 0x65, 0x6c, 0x2c, 0x20,
	0x74, 0x69, 0x6d, 0x65, 0x72, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x4c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x3a, 0x20, 0x65, 0x6e, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65,
	0x70, 0x74, 0x2d, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x3a, 0x20, 0x69, 0x64, 0x65,
	0x6e, 0x74, 0x69, 0x74, 0x79, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x3a, 0x20, 0x61,
	0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x73, 0x64, 0x70, 0x2c, 0x20,
	0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x69, 0x73, 0x75, 0x70,
	0x2c, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x61, 0x72, 0x74, 0x2f, 0x6d, 0x69, 0x78, 0x65,
	0x64, 0x0d, 0x0a, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x3a, 0x20, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45,
	0x2c, 0x20, 0x41, 0x43, 0x4b, 0x2c, 0x20, 0x43, 0x41, 0x4e, 0x43, 0x45, 0x4c, 0x2c, 0x20, 0x42,
	0x59, 0x45, 0x2c, 0x20, 0x4f, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x2c, 0x20, 0x4e, 0x4f, 0x54,
	0x49, 0x46, 0x59, 0x2c, 0x20, 0x50, 0x52, 0x41, 0x43, 0x4b, 0x2c, 0x20, 0x55, 0x50, 0x44, 0x41,
	0x54, 0x45, 0x2c, 0x20, 0x49, 0x4e, 0x46, 0x4f, 0x2c, 0x20, 0x52, 0x45, 0x46, 0x45, 0x52, 0x0d,
	0x0a, 0x0d, 0x0a, 0x76, 0x3d, 0x30, 0x0d, 0x0a, 0x6f, 0x3d, 0x2d, 0x20, 0x30, 0x20, 0x30, 0x20,
	0x49, 0x4e, 0x20, 0x49, 0x50, 0x34, 0x20, 0x30, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x30, 0x0d, 0x0a,
	0x73, 0x3d, 0x2d, 0x0d, 0x0a, 0x63, 0x3d, 0x49, 0x4e, 0x20, 0x49, 0x50, 0x34, 0x20, 0x30, 0x2e,
	0x30, 0x2e, 0x30, 0x2e, 0x30, 0x0d, 0x0a, 0x74, 0x3d, 0x30, 0x20, 0x30, 0x0d, 0x0a, 0x6d, 0x3d,
	0x61, 0x75, 0x64, 0x69, 0x6f, 0x20, 0x30, 0x20, 0x52, 0x54, 0x50, 0x2f, 0x41, 0x56, 0x50, 0x20,
	0x38, // -
}

var (
	header = []byte{0x48, 0x45, 0x50, 0x33} // Header - HEP3 - 4
	// Valid Chunks
	// Chunk 1: Version
	protoFamily = []byte{0x0, 0x0, 0x0, 0x01, 0x0, 0x7, 0x2} // Protocol Family - IPv4 - 7
	// Chunk 2: Protocol
	protoID = []byte{0x0, 0x0, 0x0, 0x02, 0x0, 0x7, 0x11} // Protocol ID - UDP - 7
	// Chunk 3: SrcIP
	srcIPv4 = []byte{0x0, 0x0, 0x0, 0x03, 0x0, 0xa, 0xc0, 0xa8, 0xf7, 0xfa} // SrcIP - 10
	// Chunk 4: DstIP
	dstIpv4 = []byte{0x0, 0x0, 0x0, 0x04, 0x0, 0xa, 0xc0, 0xa8, 0xf5, 0xfa} // DstIP - 10
	// Chunk 7: SrcPort
	srcPort = []byte{0x0, 0x0, 0x0, 0x07, 0x0, 0x8, 0x13, 0xc4} // SrcPort - 8
	// Chunk 8: DstPort
	dstPort = []byte{0x0, 0x0, 0x0, 0x08, 0x0, 0x8, 0x13, 0xc4} // DstPort -8
	// Chunk 9: Tsec
	tsec = []byte{0x0, 0x0, 0x0, 0x09, 0x0, 0xa, 0x66, 0x0b, 0x53, 0xf9} // Tsec - 10
	// Chunk 10: Tmsec
	tmsec = []byte{0x0, 0x0, 0x0, 0x0a, 0x0, 0xa, 0x0, 0x1, 0xd2, 0xf4} // Tmsec - 10
	// Chunk 11: ProtoType
	protoType = []byte{0x0, 0x0, 0x0, 0x0b, 0x0, 0x7, 0x1} // ProtoType - SIP - 7
	// Chunk 12: NodeID
	nodeID = []byte{0x0, 0x0, 0x0, 0x0c, 0x0, 0xa, 0x0, 0x0, 0x0, 0x65} // NodeID - 101 - 10
	// Chunk 14: NodePW
	nodePW = []byte{0x0, 0x0, 0x0, 0x0e, 0x0, 0xc, 0x70, 0x61, 0x73, 0x73, 0x77, 0x64} // NodePW - passwd - 16
	// Chunk 15: Payload
	payload = append([]byte{0x0, 0x0, 0x0, 0x0f, 0x2, 0xa7}, sipPayload...) // Payload - 679
	// Chunk 18: Vlan
	vlan = []byte{0x00, 0x00, 0x00, 0x12, 0x00, 0x08, 0x00, 0x00} // Vlan - 8
	// Chunk 1: Version
	invalidProtoFamilyLength = []byte{0x0, 0x0, 0x0, 0x01, 0x0, 0x8, 0x2} // Protocol Family - IPv4 - 7
	// Chunk 1: Version
	invalidProtoFamily = []byte{0x0, 0x0, 0x0, 0x01, 0x8} // Protocol Family - IPv4 - 7
	// Chunk 1: Version
	invalidProtoFamily2 = []byte{0x0, 0x0, 0x0, 0x01, 0x8, 0x2} // Protocol Family - IPv4 - 7
	// Chunk 1: Version
	invalidProtoFamily3 = []byte{0x0, 0x0, 0x0, 0x01, 0x0, 0x2, 0x1} // Protocol Family - IPv4 - 7

	// Unkonwn Chunks
	unkonwnChunk = []byte{0x0, 0x0, 0x0, 0x21, 0x0, 0x7, 0x2} // Protocol Family - IPv4 - 7
	// Unkonwn Chunks
	unkonwnChunkVendor = []byte{0x0, 0xa, 0x0, 0x01, 0x0, 0x7, 0x2} // Protocol Family - IPv4 - 7
)

var validPacket = slices.Concat(
	header,
	[]byte{0x3, 0x18},
	protoFamily,
	protoID,
	srcIPv4,
	dstIpv4,
	srcPort,
	dstPort,
	tsec,
	tmsec,
	protoType,
	nodeID,
	nodePW,
	payload,
	vlan,
)

var validOutOfOrderChunksPacket = slices.Concat(
	header,
	[]byte{0x3, 0x18},
	protoFamily,
	protoID,
	dstIpv4,
	srcIPv4,
	srcPort,
	dstPort,
	tsec,
	tmsec,
	protoType,
	nodePW,
	nodeID,
	payload,
	vlan,
)

var invalidLengthPaket = slices.Concat(
	header,
	[]byte{0x0, 0x18},
	protoFamily,
	protoID,
	srcIPv4,
	dstIpv4,
	srcPort,
	dstPort,
	tsec,
	tmsec,
	protoType,
	nodeID,
	nodePW,
	payload,
	vlan,
)

var invalidChunkLengthPaket = slices.Concat(
	header,
	[]byte{0x3, 0x18},
	invalidProtoFamilyLength,
	protoID,
	srcIPv4,
	dstIpv4,
	srcPort,
	dstPort,
	tsec,
	tmsec,
	protoType,
	nodeID,
	nodePW,
	payload,
	vlan,
)

var invalidChunkPaket = slices.Concat(
	header,
	[]byte{0x0, 0x0b},
	invalidProtoFamily,
)

var invalidChunkPaket2 = slices.Concat(
	header,
	[]byte{0x0, 0x0c},
	invalidProtoFamily2,
)

var invalidChunkPaket3 = slices.Concat(
	header,
	[]byte{0x0, 0x0d},
	invalidProtoFamily3,
)

var validWithUnkownChunksPaket = slices.Concat(
	header,
	[]byte{0x3, 0x18},
	unkonwnChunkVendor,
	unkonwnChunk,
	srcIPv4,
	dstIpv4,
	srcPort,
	dstPort,
	tsec,
	tmsec,
	protoType,
	nodeID,
	nodePW,
	payload,
	vlan,
)

func TestDecode(t *testing.T) {
	decoder := NewBinaryDecoder()

	// Test case 1: Valid HEP packet
	hepMsg, err := decoder.Decode(validPacket)
	assert.NoError(t, err)
	assert.Equal(t, byte(0x2), hepMsg.IPProtocolFamily)
	assert.Equal(t, byte(0x11), hepMsg.IPProtocolID)
	assert.Equal(t, 792, Size(hepMsg))
	assert.Equal(t, net.ParseIP("192.168.247.250").To4(), hepMsg.SrcIP)
	assert.Equal(t, net.ParseIP("192.168.245.250").To4(), hepMsg.DstIP)
	assert.Equal(t, uint16(5060), hepMsg.SrcPort)
	assert.Equal(t, uint16(5060), hepMsg.DstPort)
	assert.Equal(t, uint32(1712018425), hepMsg.Tsec)
	assert.Equal(t, uint32(119540), hepMsg.Tmsec)
	assert.Equal(t, sipPayload, hepMsg.Payload)

	encoder := NewBinaryEncoder()
	hepPacket, err := encoder.Encode(hepMsg)
	assert.NoError(t, err)
	assert.Equal(t, validPacket, hepPacket)

	// Test case 2: Valid HEP packet with out of order Chunks
	hepMsg, err = decoder.Decode(validOutOfOrderChunksPacket)
	assert.NoError(t, err)
	assert.Equal(t, byte(0x2), hepMsg.IPProtocolFamily)
	assert.Equal(t, byte(0x11), hepMsg.IPProtocolID)
	assert.Equal(t, 792, Size(hepMsg))
	assert.Equal(t, net.ParseIP("192.168.247.250").To4(), hepMsg.SrcIP)
	assert.Equal(t, net.ParseIP("192.168.245.250").To4(), hepMsg.DstIP)
	assert.Equal(t, uint16(5060), hepMsg.SrcPort)
	assert.Equal(t, uint16(5060), hepMsg.DstPort)
	assert.Equal(t, uint32(1712018425), hepMsg.Tsec)
	assert.Equal(t, uint32(119540), hepMsg.Tmsec)
	assert.Equal(t, sipPayload, hepMsg.Payload)

	h2, err := decoder.Decode(hepPacket)
	assert.NoError(t, err)
	assert.Equal(t, hepMsg, h2)

	// Test case 3: Invalid HEP packet length
	_, err = decoder.Decode(invalidLengthPaket)
	assert.Error(t, err)
	assert.EqualError(t, err, "HEP packet length is 792 but should be 24")

	// Test case 4: Invalid Chunk length
	_, err = decoder.Decode(invalidChunkLengthPaket)
	assert.Error(t, err)
	assert.EqualError(t, err, "IP Protocol Family chunk should be 1 byte long but is 2")

	// Test case 5: Not enough data for chunk
	_, err = decoder.Decode(invalidChunkPaket)
	assert.Error(t, err)
	assert.EqualError(t, err, "HEP chunk must be >= 6 byte long but is 5")

	// Test case 6: Invalid Chunk
	_, err = decoder.Decode(invalidChunkPaket2)
	assert.Error(t, err)
	assert.EqualError(t, err, "HEP chunk with 6 byte < chunkLength 2050 or chunkLength < 6")

	// Test case 7: Invalid Chunk
	_, err = decoder.Decode(invalidChunkPaket3)
	assert.Error(t, err)
	assert.EqualError(t, err, "HEP chunk with 7 byte < chunkLength 2 or chunkLength < 6")

	// Test case 8: Packet with unkown chunks
	hepMsg, err = decoder.Decode(validWithUnkownChunksPaket)
	assert.NoError(t, err)
	assert.Empty(t, hepMsg.IPProtocolFamily)
	assert.Empty(t, hepMsg.IPProtocolID)
	assert.Equal(t, uint16(5060), hepMsg.SrcPort)
	assert.Equal(t, uint16(5060), hepMsg.DstPort)
	assert.Equal(t, sipPayload, hepMsg.Payload)
}

func TestTimestampDecode(t *testing.T) {
	encoder := NewBinaryEncoder()
	decoder := NewBinaryDecoder()
	timestamp := time.Unix(0, time.Now().UnixNano())
	message := &hep.Message{
		Timestamp: timestamp,
	}
	hepPacket, err := encoder.Encode(message)
	assert.NoError(t, err)
	hepMsg, err := decoder.Decode(hepPacket)
	assert.Equal(t, timestamp, hepMsg.Timestamp)

	message = &hep.Message{
		Timestamp: timestamp,
		Tsec:      uint32(1721701731),
		Tmsec:     uint32(0),
	}
	hepPacket, err = encoder.Encode(message)
	fmt.Println(hepPacket)
	assert.NoError(t, err)
	hepMsg, err = decoder.Decode(hepPacket)
	timestamp = time.Unix(1721701731, 0)
	assert.Equal(t, timestamp, hepMsg.Timestamp)

	message = &hep.Message{
		Tsec: uint32(1721701731),
	}
	hepPacket, err = encoder.Encode(message)
	assert.NoError(t, err)
	hepMsg, err = decoder.Decode(hepPacket)
	timestamp = time.Unix(1721701731, 0)
	assert.Equal(t, timestamp, hepMsg.Timestamp)

	message = &hep.Message{
		Tmsec: uint32(58647),
	}
	hepPacket, err = encoder.Encode(message)
	assert.NoError(t, err)
	hepMsg, err = decoder.Decode(hepPacket)
	timestamp = time.Unix(0, 58647000)
	assert.Equal(t, timestamp, hepMsg.Timestamp)
}

func BenchmarkDecode(b *testing.B) {
	decoder := NewBinaryDecoder()

	for i := 0; i < b.N; i++ {
		decoder.Decode(validPacket)
	}
}
